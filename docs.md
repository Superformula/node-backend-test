# README
---

Users API exposes the ability to view and manage users.


## API Docs
Swagger UI available at `/documentation` endpoint.

### Actions
##### CREATE USER
POST /api/v1/users/

Response Type: Single Entity (User)

This endpoint allows creation of a new user record. 

If a value for the `id` property is provided in the request, it will be subject to uniqueness across all users. A `409` status code is returned if the `id` already exists. If not provided, a unique uuid will be generated by the API. 

##### LIST USERS
GET /api/v1/users/

Response Type: Collection (UserList)

Lists all available user records, summarized, and ordered by most recently updated users. Each user record has `name`, `updatedAt`, and `id` properties. 

Pagination is supported via `limit` and `page` properties in the query params. By default, the following values are used: 

- `limit` = 10
- `page` = 1

##### UPDATE USER
PUT /api/v1/users/{userId}

Response Type: Single Entity (User)

This endpoint allows for replacing of the existing user record with the one provided. This means that any ommitted properties will be set to `null`.

`userId` must be the `id` property of an existing user.

Read-only properties such as `id`, `createdAt`, and `updatedAt` cannot be modified and cannot be provided in the request body.


##### DELETE USER
DELETE /api/v1/users/{userId}

Response Type: Empty

Will return 200 if the `userId` is found and deleted. Will return 400 if the `userId` was not found.

### Standards 

#### Strong Consistency
Users API follows strong consistency. If an endpoint responds successfully, it means the operation was successfully completed and is reflected in the datastore. Unless otherwise noted, it is not necessary to account for eventual consistency.

#### Responses
##### Success
A successful response may be of three varieties: empty, single entity, or collection.

###### Empty
An empty response will contain no discernable body or headers. Only the HTTP status code is meaningful in this response type

###### Single Entity
When responding with a single entity, the response will contain a `type` and an `item` property. This is the most common type of response in the Users API.

Example response
```json
{
  "type": "User",
  "item": {
    "id": "9989b070-c4f5-11e8-8936-7bcfecbaf8e6",        
    "name": "Jack O'niell",                              
    "dob": "1989-10-01T00:00:00.000Z",
    "description": "Jack has served on SG-1 10+ years.", 
    "createdAt": "2018-10-01T03:52:47.093Z",
    "updatedAt": "2018-10-01T04:19:16.068Z",
  }
}
```

###### Collection
The collection response type contains `type` and `items` properties. The `type` property is always in plural form for this response type. The `items` property is an array of objects, each of which can be thought of as a single instance of a single entity response.

Example response:
```json
{
  "type": "Users",
  "items": [
    {
      "id": "9989b070-c4f5-11e8-8936-7bcfecbaf8e6",        
      "name": "Jack O'niell",                              
      "dob": "1989-10-01T00:00:00.000Z",
      "description": "Jack has served on SG-1 10+ years.", 
      "createdAt": "2018-10-01T03:52:47.093Z",
      "updatedAt": "2018-10-01T04:19:16.068Z",
    }
  ]
}
```

##### Unsuccessful
All unsuccessful responses will follow the [`boom`](https://github.com/hapijs/boom) base model:

```json
{
    "statusCode": 400,
    "error": "Bad Request",
    "message": "invalid query"
}
```

#### User Model

Anytime a user record is provided, it will use the user object model noted in the snippet below.

```js
{
  "id": "9989b070-c4f5-11e8-8936-7bcfecbaf8e6",         // Must be a valid UUID
  "name": "Jack O'niell",                               // Limited to 64 characters
  "dob": "1989-10-01T00:00:00.000Z",
  "description": "Jack has served on SG-1 10+ years.",  // Limited to 250 characters
  "createdAt": "2018-10-01T03:52:47.093Z",
  "updatedAt": "2018-10-01T04:19:16.068Z",
}
```

- All date fields must be in UTC timezone and ISO 8601 date format.
- `createdAt` and `updatedAt` are API-controlled read-only properties.
- any properties not provided during creation or updating operations will be defaulted to `null`

## Resources

This repo account's for two main runtime resources: a MongoDB datastore container and the Users API node.js container

### API

- Uses the `hapi` Node.js framework
- Is a simple docker continer defined in `Dockerfile`
    - Uses the latest `node` docker container as base
- Expects all runtime keys such as the MongoDB container info to be provided via environment variables
- Is linked to the MongoDB container for direct network traffic

### MongoDB

- Latest version of `mongo` docker container as base
- Mounts a volume to its host's `./data` directory for persisting the data

## Design / Strategies

### Access
#### Authentication Strategy
Authentication is not yet present for this API. However, due to the sensitive, core-system nature of managing users, it is important for a standardized user authenthication gate to be present.

The recommended approach is a token-based authentication mechanism such as JWTs vended through a core authentication API. This authentication API can be the single source of truth for identity management that all sister services, consumers, and downstream processes to Users API can also respect in a cohesive microservices ecosystem. 

A token would then be required as a header (`Authorization: Bearer {token}`) along with all requests to this and other APIs. Each endpoint would be responsible for verifying the token before proceeding with the request.

Once implemented, all non-idempotent actions should record the requesting user for auditing purposes. This can be done naively on the User entity or in a separate audit datastore with more details.

#### Authorization Strategy
Authorization gates are not yet present but are critical for all actions available in Users API.

The recommended approach is to:

1. Recognize all domain-level actions available in this API: 
    - `users:list`, `user:read`, `user:create`, `user:write`, `user:delete`
2. Associate each action with a user or group of users through a standard policy management solution. This can be a microservice or a 3rd party user/group policy management solution.
3. Add an authorization check for each endpoint to check if the requesting user has a policy attached to their profile or any of the groups they belong to in the Authorization service to take this action. 

### Logging Strategy

#### Log Levels
In order to have a microservice plug and play into a larger ecosystem gracefully, it must follow common standards. All logging by Users API respects the standard log lovels:

- `debug` - Only relevant when running the application for testing or development purposes.
- `info`  - Informative logging to provide clarity on an operation performed by the service, its health, or its bootstrap transitions. 
- `warn`  - A log seeking human investigation or intervention. These are not explicit errors but instead paths recognized to have runtime integrity compromising potential.
- `error` - An log with `error` log level is an unhandled path in the application. It was not accounted for and caused the application to provide unexpected results to the requestor. All errors should be immediately vetted for priority and then investigated and fixed accordingly. The goal should be to have 0 errors in runtime at all times.

#### Distributed Log Collection
One common strategy in large-scale microservices infrastructures is to treat all runtime processes (FaaS, containers, VMs, etc.) the same by requiring them all to log to stdout or stderr. Their output is then collected and managed live by a log aggregation process running alongside all APIs, workers, or serverless pipelines. This aggregation process is then responsible for shipping these logs to a centralized logging datastore such as Elasticsearch or a 3rd party provider.

This allows that centralized logging datastore to provide meaningful, cross-functional insights in realtime for the health of the overall microservices ecosystem. In this case, it would also remove the burden from each service, including this one, to manage logs, their integration with frameworks, their temporary persistence in files or how to ship them to APIs. The responsibility of Users API, and all other services, would be simplified to:

1. always logging to stdout 
2. using a standard logging structure

This strategy would also pave the path to allow for transitioning these services, if necessary, to cloud-native solutions such as Azure or AWS, which natively support centralized logging infrastructure and tooling across all of their services. 

#### Logging Structure
In order for a centralized logging data store to provide value, logs must be represented in a similar fashion across all services. In this case, the recommended guidance is to have all services log either standard tabular format or JSON with schema of:

`time`, `serviceName`, `sourceVersion`, `buildVersion`, `severity`, `message`